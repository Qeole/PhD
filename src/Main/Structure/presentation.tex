% vim: set spelllang=fr foldmethod=marker:
\section{Contexte}
\label{st:sec:contexte}
%===============================================================================
    \subsection{Réseaux de capteurs sans fil}

        \subsubsection{De quoi s'agit-il?}
Les réseaux de capteurs sans fil, ou \textit{WSN} (pour \textit{Wireless Sensor Networks} en anglais), sont des réseaux constitués de petits appareils, les capteurs, ainsi que d'une station de base.
Les capteurs échangent par communications hertziennes, en utilisant des protocoles tels IEEE~802.11.
Le routage des paquets dans le réseau peut faire appel à l'un des nombreux protocoles développés à cet effet (par exemple: \textit{AODV}, \textit{OLSR}), qu'il repose sur un algorithme centralisé (dirigé par une seule entité) ou distribué (exécuté par chaque entité du réseau).
Ils collectent des informations sur leur environnement et les font remonter à la station de base.
Cette station de base, ou \BS (pour \textit{Base Station}), parfois appelée \textit{puits} (ou \textit{sink} en anglais), est chargée de récolter et traiter les données provenant des capteurs.
Une fois les capteurs déployés, l'administrateur n'interagit plus avec le réseau que par le biais de la station de base.

Quel que soit le protocole de liaison de données utilisé, il est rare que tous les capteurs d'un WSN soit directement connectés les uns aux autres.
À la topologie d'un réseau donné est donc très souvent associé le graphe de connectivité du réseau.
Pour cette raison, dans la littérature comme dans la suite de ce document, il sera souvent fait référence aux capteurs sous le terme de \textit{nœuds} (\textit{nodes} en anglais).

        \subsubsection{Applications}
Le champ d'application des WSN est très vaste.
Des réseaux peuvent être mis en place en forêt, par exemple, afin de détecter les départs de feu et de lutter plus efficacement contre les incendies.
D'autres peuvent être déployés en mer, afin de mesurer le taux de pollution des eaux.
En zones à risques, les capteurs peuvent être utilisés pour mesurer l'activité sismique ou volcanique du sol, et permettre une meilleure anticipation des phénomènes naturels.

Les WSN sont également utilisés dans certains milieux critiques.
Un exemple serait leur usage dans le domaine du nucléaire.
Un autre, de taille, est leur exploitation intensive par les militaires sur les champs de batailles, afin de relier fantassins et véhicules de tous types; un maximum d'informations doit alors être remonté au centre de commandement, afin de permettre une supervision optimale des forces en mouvement.

Un autre domaine d'application en voie de développement est ce que l'on appelle l'\textit{Internet des objets} (\textit{the Internet of things} en anglais), et qui consiste en quelque sorte à étendre Internet au monde réel, par le biais d'une interconnexion réseau entre les objets de la vie courante.

        \subsubsection{Contraintes en ressources}
De par leur petite taille, et à cause de leurs déploiement dans des zones souvent difficiles d'accès, les capteurs n'embarquent qu'une quantité limitée de matériel, qui ne peut pas toujours être remplacé.
Les capteurs se retrouvent donc avec des capacités limitées, notamment en ce qui concerne:
\begin{itemize}
    \item les capacités de calcul: les processeurs embarqués sont relativement peu puissants.
        Les algorithmes exécutés par les capteurs doivent donc être de complexité relativement basse;
    \item les capacités de mémoire: les capteurs disposent de RAM et d'un peu d'espace de stockage, mais ils ne sont pas du tout conçus pour sauvegarder de grandes bases de données.
        Les informations récoltées doivent être acheminées à la station de base, et non stockées sur le long terme par les capteurs eux-mêmes;
    \item l'énergie disponible: les capteurs disposent d'une batterie qui leur fournit une quantité d'énergie finie, et (la plupart du temps) non rechargeable.
        Il est donc essentiel de conserver à l'esprit une gestion parcimonieuse de l'énergie pour tout programme implémenté sur les capteurs.
        Des calculs importants, ainsi que des émissions/réceptions d'ondes électromagnétiques nombreuses ou mal gérées, sont les principaux facteurs d'un épuisement prématuré de la batterie. 
\end{itemize}

Il est à noter qu'au regard de ces contraintes qui affectent les capteurs, la station de base est considérée comme disposant de capacités illimitées.

        \subsubsection{Sécurité}
En raison de leurs faibles capacités, conjuguées aux domaines critiques dans lesquels ils interviennent parfois, les capteurs peuvent présenter des cibles de choix pour un attaquant.
Les algorithmes et mécanismes classiques utilisés en cryptographie afin d'assurer la confidentialité ou l'authentification des données sont souvent très exigeants en ressources (en termes de calcul notamment, et donc de consommation énergétique).
Il a fallu adapter ces mécanismes aux capteurs.

D'autres attaques peuvent être menées, non plus pour intercepter des données, mais dans le but de perturber le bon fonctionnement du réseau.
Ce sont les attaques dites de \textit{déni de service}.
Un attaquant, par le biais d'un nœud compromis par exemple, peut ainsi chercher à détourner des flux de données au sein du réseau, à empêcher des paquets de parvenir à destination (en les supprimant), à maximiser le débit du nœud compromis au détriment de celui des autres nœuds, à saturer le canal pour empêcher les nœuds légitimes de l'utiliser, ou encore à pousser les autres capteurs à l'épuisement de leurs réserves en énergie, \etc.

Notre but est ici de proposer, modéliser et tester une solution permettant de détecter, puis de réagir à une attaque de ce type, tout en assurant une consommation minimale en ressources pour les capteurs du réseau.
L'une des possibilités permettant de réduire la consommation en énergie est l'utilisation d'un réseau hiérarchiquement clusterisé.

%===============================================================================
    \subsection{Partition hiérarchique des nœuds du réseau}
    \label{st:subsec:partition}

        \subsubsection{Partition du réseau}
«~Clusteriser~» un ensemble d'éléments revient à le diviser en sous-ensembles appelés \textit{clusters}.
Dans le cas des réseaux de capteurs sans fil, cette partition permet d'obtenir un routage efficace des paquets, en adoptant la configuration suivante:
\begin{enumerate}
    \item tous les nœuds réunis au sein d'un même cluster sont capables de communiquer directement entre eux (\textit{one-hop transmission});
    \item lors de la partition, un unique nœud par cluster est désigné «~chef~» du cluster.
        Il est choisi, de façon déterministe ou bien aléatoire selon l'algorithme employé, parmi les nœuds «~normaux~» du cluster.
        Ce «~chef~» est appelé \ch (\CH);
    \item lorsqu'un capteur quelconque d'un cluster souhaite faire parvenir des informations à un nœud d'un autre cluster\footnote{Pour une grande partie des applications, les communications entre nœuds de différents clusters, hors \chs, ne se produisent pas. La totalité du trafic «~utile~», acheminant des données, est généralement à destination de la station de base.}, ou bien à la station de base, il envoie ses paquets de données au \ch de son cluster ;
    \item le \ch transmet alors les paquets de données, soit directement à la cible s'il s'agit de la station de base et qu'il peut l'atteindre, soit en passant par d'autres \chs (\textit{multi-hops transmission}), jusqu'à atteindre le destinataire.
\end{enumerate}
L'appel à un algorithme de clusterisation a pour effet de limiter les émissions à «~longue portée~» (relativement aux communications intra-clusters) aux \textit{cluster heads} seulement.
Hors les communications sur de plus grandes distances se traduisent par une plus grande consommation en énergie (puisqu'une plus grande puissance d'émission est nécessaire).
Les capteurs «~normaux~» (non \chs) n'ont pas à atteindre directement des nœuds situés en dehors de leur cluster; ils économisent d'autant en énergie.
De plus, dans la limite de leurs capacités, les \chs sont généralement amenés à réaliser des opérations d'agrégation voire parfois de compression sur les paquets qu'ils reçoivent, afin de limiter encore les transmissions coûteuses.

De nombreux algorithmes de clusterisation de données existent.
Plusieurs d'entre eux sont même spécifiquement adaptés aux réseaux de capteurs sans fil.
Parmi les plus fréquemment utilisés, on trouve des algorithmes comme \leach~\cite{HCB00} ou \textit{HEED}~\cite{YF04}.
D'autres sont moins connus, comme \textit{FFUCA}~\cite{FL11}, qui repose sur l'exploitation de propriétés ultramétriques dans le réseau.

        \subsubsection{Clusterisation hiérarchique}
Une fois le réseau de capteurs divisé en clusters, rien n'empêche de considérer les clusters un à un et de leur appliquer à nouveau un algorithme de clusterisation, de façon à établir des sous-ensembles dans chaque cluster.
Et ainsi de suite, de façon récursive, jusqu'à atteindre le degré de hiérarchie désiré.
L'intérêt de cette méthode est de créer une partition hiérarchique dans le réseau, permettant un meilleur contrôle des sous-ensembles de capteurs.
Par ailleurs, les clusters situés tout en bas dans la hiérarchie constituée seront de petite taille.
Les communications intra-clusters seront donc peu consommatrices en énergie.

Pour pouvoir distinguer plus facilement le niveau de hiérarchie auquel nous nous plaçons, nous désignerons par la suite sous le terme \textit{$k$-cluster} ($0 \leq k \leq$~nombre de capteurs) un sous-ensemble obtenu après $k$ applications de l'algorithme de clusterisation.
En suivant cette convention, l'unique $0$-cluster est alors le réseau tout entier.
Lorsque nous parlons simplement de \textit{clusters}, il faudra comprendre \textit{$1$-clusters}; autrement dit, des clusters issus d'une partition simple, sans degré supplémentaire de hiérarchie.

De même, on désignera par \textit{$k$-cluster head} (ou bien par \textit{$k$-CH}) les \chs de chacun des $k$-clusters du réseau.
Le rôle de $0$-cluster pourra alors être attribué à la station de base.
Chaque \textit{$k$-CH} reçoit des données (provenant soit de nœuds normaux si $k$ est le dernier degré de la hiérarchie constituée, soit de \textit{$k+1$-CH}), les agrège et les transmet au \textit{$k-1$-CH} auquel il est rattaché.

        \subsubsection{Exemple: fonctionnement de l'algorithme \leach}
        \label{st:subsubsec:leach}
L'un des algorithmes de clusterisation les plus simples et les plus couramment employés dans les réseaux de capteurs sans fil est l'algorithme \leach (\textit{Low Energy Adaptive Clustering Hierarchy with deterministic cluster-head selection}).
Il s'agit d'un algorithme dynamique (il effectue de nouvelles clusterisations du réseau régulièrement dans le temps) qui, par la formation de clusters, met en place une solution de routage des paquets dans le réseau.

Voici le fonctionnement détaillé de cet algorithme.
Soit $P$ le pourcentage moyen de clusters que nous désirons obtenir dans le réseau à un instant quelconque $t$.
\leach est découpé (dans la durée) en cycles, chacun constitué de $\frac{1}{P}$~rondes.
Chaque ronde $r$  est organisée de la façon suivante:
\begin{enumerate}
    \item Chaque nœud du réseau à partitionner calcule une valeur de seuil $S(i)$:
        \[
            S(i) = \left\{
            \begin{array}{cl}
                \displaystyle \frac{P}{1-P\cdot\left(r\mbox{ mod }\frac{1}{P}\right)} & \mbox{si }i\mbox{ n'a pas encore été \CH}\\
                                                                                    0 & \mbox{si }i\mbox{ a déjà été \CH}
            \end{array}
            \right.
        \]
        Chaque nœud choisit un nombre pseudo-aléatoire $0 \le x_{i}\le 1$.
        Si $x_{i} \le S(i)$, alors $i$ s'auto-désigne comme \CH pour la ronde en cours.
        Il est à noter que le calcul de $S(i)$ est réalisé de telle façon que chaque nœud devienne \ch une fois et une fois seulement au cours de chaque cycle de $\frac{1}{P}$~rondes: le taux de probabilité d'auto-désignation $S(i)$ est égal à $1$ lorsque la fin du cycle est atteinte (autrement dit, lorsque $r = \frac{1}{P}-1$).
    \item Les \chs auto-désignés informent leurs nœuds voisins de leur changement de statut à l'aide de messages en \textit{broadcast}.
        Tous ces messages sont envoyés en utilisant la même puissance de transmission (valeur fixe et prédéterminée lors de l'implémentation).
        Pour limiter les collisions, il est fait usage de la méthode \textit{Carrier Sense Multiple Access} (\textit{CSMA}) au niveau de la couche \textit{MAC}.
    \item Les autres nœuds, qui ne se sont pas désignés en tant que \chs pour la ronde en cours, choisissent de se joindre au cluster du \CH dont ils perçoivent le signal avec l'intensité la plus élevée, c'est à dire le \CH le plus proche en termes d'émissions électromagnétiques.
        Chaque nœud prévient le \ch qu'il décide de rejoindre en lui envoyant un message.
        La méthode \textit{CSMA} est là encore appliquée.
    \item Au vu des réponses reçues, chaque \ch calcule un «~ordre de transmission~» pour les nœuds qui l'ont rejoint.
        Il annonce alors à chacun de ces nœuds l'instant auquel le nœud doit lui transmettre ses données.
        Dans chaque cluster, les nœuds s'adresseront donc à leur \ch à tour de rôle, selon l'ordre déterminé par le \CH, ce qui revient à utiliser la méthode appelée \textit{Time Division Multiple Access} (\textit{TDMA}).
    \item La phase de collecte des données peut débuter.
        Les \chs restent en écoute et reçoivent les données des autres capteurs de leur cluster.
        Les capteurs «~normaux~» effectuent leur mission (en général, ils réalisent des mesures sur leur environnement), et envoient leurs résultats au \ch lorsque c'est à leur tour de le faire.
        Lorsque ce n'est pas à leur tour de communiquer, ces nœuds mettent leur équipement radio en veille afin d'économiser leur énergie.
        Les collisions entre les transmissions des nœuds de différents clusters sont évitées grâce à la méthode appelée \textit{Code Division Multiple Access} (\textit{CDMA}).
    \item Au fur et à mesure qu'ils reçoivent les données, les \chs agrègent, et éventuellement compressent ces dernières.
        Ils les envoient ensuite à la station de base, soit au cours d'une unique transmission directe, soit en faisant relayer les paquets par d'autres \chs.
    \item Les étapes 5) et 6) sont répétées jusqu'à la fin de la ronde.
\end{enumerate}

Plusieurs remarques sont à énoncer.
Tout d'abord: pour un cluster donné, il est alors possible de réitérer l'application de l'algorithme \leach, afin de créer une nouvelle partition au sein même d'un cluster.
Et ainsi de suite par récursivité, jusqu'à obtenir le degré de hiérarchie désiré dans le réseau.
Nous appellerons $k$-\leach cet algorithme appliqué de façon à créer $k$ degrés hiérarchiques.

Seconde remarque: il est possible d'étendre \leach pour prendre en compte l'énergie restante dont dispose chaque nœud lors de l'élection des \CH.
Cette énergie restante intervient alors en temps que paramètre supplémentaire lors du calcul de la valeur de seuil $S(i)$~\cite{HHT02}.

Troisième point: l'un des aspects importants de \leach est que lors de la première étape, chaque nœud choisi d'être, ou non, un \ch pour la ronde en cours.
Ce choix est basé uniquement sur la valeur de seuil calculée, et sur le nombre pseudo-aléatoire généré; à aucun moment un nœud ne fait intervenir dans sa décision le comportement de ses voisins.
En conséquence, le pourcentage $P$ de \chs désirés dans le réseau n'est qu'une valeur moyenne sur l'ensemble des rondes de chaque cycle.
Par ailleurs, la répartition géographique (au regard de la puissance de transmission nécessaire) idéale des \chs n'est en rien assuré.
Au contraire, il est même probable d'obtenir, pour certaines rondes, une concentration importante de \chs dans une zone restreinte du réseau, tandis que d'autres régions seront mal couvertes.
Il n'y a pas grand-chose à faire dans ce cas, sinon espérer que la prochaine ronde sera plus favorable.
Si toutefois un nœud ne parvient à capter les messages d'aucun \ch, il se déclare généralement lui-même \CH.
