% vim: set spelllang=fr foldmethod=marker:
\section{Quelques problématiques}

De par leurs ressources faibles, leur dispersion dans un environnement parfois hostile, leurs communications sans fil, et les différentes missions qui leur sont confiées, les \rcsfs introduisent une multitude de problématiques que l'on ne retrouve pas ou peu dans d'autres types de réseaux.
Nous introduisons ici celles qui sont indispensables à la compréhension des travaux de cette thèse.

    \subsection{Gestion des ressources et performances}
Les évolutions technologiques des dernières décennies n'ont de cesse de rendre les ordinateurs plus performants, plus compacts, plus rapides dans le traitement des données.
Elles ont rendu possible, à force de miniaturisation et de réduction des couts, la création et le déploiement des \rcsfs, mais ceux-ci restent soumis à des contraintes en ressources très fortes par rapport aux stations de travail « classiques » tel que les ordinateurs personnels (y compris portables).

        \subsubsection{Des algorithmes à adapter}
Les algorithmes et protocoles déployés dans les \rcs doivent être peu exigeants en terme de calculs.
Il est même possible de réduire les calculs en amont, en sélectionnant judicieusement les échantillons de donner à mesurer puis à analyser, pour éviter des calculs superflus; les algorithmes de traitement, d'\idx{agrégation} de données, doivent également être pensés pour les capteurs~\cite{ACFP09},

Les mécanismes cryptographiques\index{cryptographie} par exemple, souvent déployés pour des raisons de sécurité (et qui seront abordés plus en détail en \chapref{ea}), produisent par nature un grand nombre de calculs: les versions les plus complexes ne peuvent pas toujours être implémentées sur les réseaux de capteurs.
Le choix des algorithmes à utiliser~\cite{LDH06} en fonction de la mémoire ou de la vitesse du processeur disponibles et du niveau de sécurité requis, leur optimisation (et la création de nouveaux algorithmes)~\cite{GNL12} aussi bien que leur impact sur la durée de vie des réseaux de capteurs~\cite{PLP06} ont donc fait l'objet de plusieurs études.

L'évolution constante des technologies joue aussi son rôle dans ce domaine, et il y a fort à parier que comme partout ailleurs en informatique, des composants de plus en plus performants seront disponibles au fil du temps pour les capteurs.
Les récentes avancées sur le traitement du silicène pour la fabrication de transistors pourraient ouvrir d'ici quelques années des opportunités nouvelles~\cite{TCCGFDMA15}.

        \subsubsection{Une gestion fine de l'énergie}
L'usage d'algorithmes mal adaptés au \rcs ne fait pas que diminuer les performances du réseau au niveau de la vitesse de traitement des données: si le processeur est sollicité davantage, il va drainer plus d'énergie.
Hors il est essentiel de se montrer économe sur l'usage de la batterie des capteurs, qui ne peut généralement pas être rechargée ni remplacée à moindre frais.

Par conséquent, divers travaux ont été menés pour réduire autant que possible la consommation énergétique.
Cette thèse s'inscrit d'ailleurs dans cette lignée, pour le domaine spécifique de la lutte contre le \dds.
Mais à un niveau plus général déjà, les performances de chaque opération, qu'il s'agisse de la collecte des données, de leur traitement, de leur occupation en mémoire, et de toutes les étapes relatives à leur transmission, peuvent être optimisées dans le but d'économiser de l'énergie.
Les protocoles utilisés, le cycle de travail des capteurs, et jusqu'à la topologie même du réseau peuvent avoir un impact sur la consommation énergétique des nœuds~\cite{ACFP09}.

Par exemple, les \rcs reprennent des protocoles de \idx{routage} initialement développés pour les \idx{WANET}, qui n'ont pas systématiquement les mêmes contraintes en énergie; ont donc été proposés de nombreux algorithmes de \idx{routage} destinés spécifiquement aux \rcs.
Ainsi ERAPL (\textit{Energy-Efficient Routing Algorithm to Prolong Lifetime}, « algorithme de routage économe en énergie permettant de prolonger la durée de vie »)~\cite{ZWPT10} repose sur l'usage d'algorithmes génétiques ainsi que d'une « séquence de collecte de données » permettant d'éviter les boucles et les doublons de transmission.

On trouve aussi des solutions qui proposent d'économiser l'énergie en établissant un classement des paquets à transmettre selon leur priorité, \cad selon leur importance pour l'exploitant~\cite{SAS14}.
Ainsi les paquets prioritaires sont retransmis plus rapidement, tandis que ceux d'importance moindre peuvent attendre que le trafic soit dans des conditions telles que la transmission ne devrait consommer qu'un minimum d'énergie; la phase d'attente peut également permettre l'arrivée en mémoire tampon d'autres paquets et de procéder à leur \idx{agrégation}.

Comme pour les processeurs, les technologies intervenant dans la fabrication des batteries évoluent, et permettent d'augmenter peu à peu la longévité des nouveaux capteurs.
Certaines solutions permettent parfois de recharger la batterie à moindre cout.
Ce peut être le cas avec l'usage de cellules photovoltaïques intégrés aux capteurs.
C'est aussi une solution qui commence à être utilisée pour recharger certains capteurs piézo-électriques placés sous la surface de voies de circulation automobile, qui peuvent générer une tension électrique au passage des véhicules grâce à la pression mécanique exercée par ces derniers sur les voies~\cite{sti}.

Il se pourrait même que dans un futur plus ou moins proche, les capteurs puissent se dispenser totalement de batterie: des propositions récentes, reposant sur un mécanisme appelé \textit{ambient backscatter} (qui se traduit littéralement par « rétrodiffusion ambiante »), permet de convertir, au niveau d'un capteur, un signal électromagnétique reçu (de la \sdb par exemple) en un courant électrique suffisant pour alimenter l'appareil le temps de traiter le message et de retransmettre une réponse~\cite{LPTGWS13}.

Mais cette technologie est encore limitée, et elle est loin d'être généralisée.
En attendant, l'une des possibilités essentielles permettant de réduire la consommation en énergie est l'utilisation d'une architecture \index{clusterisation!clusterisation hiérarchique} hiérarchiquement clusterisée dans le réseau.

    \subsection{Partition hiérarchique des nœuds du réseau}%
    \label{st:subsec:partition}

        \subsubsection{Partition du réseau}
«~Clusteriser~» un ensemble d'éléments revient à le diviser en sous-ensembles appelés \textit{clusters}.
Dans le cas des \rcsfs, cette partition permet d'obtenir un routage efficace des paquets, en adoptant la configuration suivante:
\begin{enumerate}
    \item tous les nœuds réunis au sein d'un même cluster sont capables de communiquer directement entre eux (\textit{one-hop transmission});
    \item lors de la partition, un unique nœud par cluster est désigné «~chef~» du cluster.
        Il est choisi, de façon déterministe ou bien aléatoire selon l'algorithme employé, parmi les nœuds «~normaux~» du cluster.
        Ce «~chef~» est appelé \ch (\CH);\nomenclature{CH}{\textit{Cluster Head}}
    \item lorsqu'un capteur quelconque d'un cluster souhaite faire parvenir des informations à un nœud d'un autre cluster\footnote{Pour une grande partie des applications, les communications entre nœuds de différents clusters, hors \chs, ne se produisent pas. La totalité du trafic «~utile~», acheminant des données, est généralement à destination de la \sdb.}, ou bien à la \sdb, il envoie ses paquets de données au \ch de son cluster ;
    \item le \ch transmet alors les paquets de données, soit directement à la cible s'il s'agit de la \sdb et qu'il peut l'atteindre, soit en passant par d'autres \chs (\textit{multi-hops transmission}), jusqu'à atteindre le destinataire.
\end{enumerate}
Le schéma d'un réseau clusterisé est présenté en \figref{st:fig:wsn}.
\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{\chapterfig/WSN.eps}
    \caption{Schéma d'un \rc clusterisé}\label{st:fig:wsn}
\end{figure}
L'appel à un algorithme de « \idx{clusterisation} » a pour effet de limiter les émissions à «~longue portée~» (relativement aux communications intra-clusters) aux \chs seulement.
Hors les communications sur de plus grandes distances se traduisent par une plus grande consommation en énergie (puisqu'une plus grande puissance d'émission est nécessaire).
Les capteurs «~normaux~» (non \chs) n'ont pas à atteindre directement des nœuds situés en dehors de leur cluster; ils économisent d'autant en énergie.
De plus, dans la limite de leurs capacités, les \chs sont généralement amenés à réaliser des opérations d'\idx{agrégation} voire parfois de \idx{compression} sur les paquets qu'ils reçoivent, afin de limiter encore les transmissions couteuses.

De nombreux algorithmes de \idx{clusterisation} de données existent.
Plusieurs d'entre eux sont même spécifiquement adaptés aux \rcsfs.
Parmi les plus fréquemment utilisés, on trouve des algorithmes comme \leach~\cite{HCB00} ou \heed~\cite{YF04}.
D'autres sont moins connus, comme \ffuca~\cite{FL11}, qui repose sur l'exploitation de propriétés ultramétriques dans le réseau.
\nomenclature{LEACH}{\textit{Low-Energy Adaptive Clustering Hierarchy}}
\nomenclature{HEED}{\textit{Hybrid, Energy-Efficient Distributed clustering}}
\nomenclature{FFUCA}{\textit{Fast and Flexible Unsupervised Clustering Algorithm }}

        \subsubsection{Clusterisation hiérarchique\index{clusterisation!clusterisation hiérarchique}}
Une fois le \rc divisé en clusters, rien n'empêche de considérer les clusters un à un et de leur appliquer à nouveau un algorithme de \idx{clusterisation}, de façon à établir des sous-ensembles dans chaque cluster.
Et ainsi de suite, de façon récursive, jusqu'à atteindre le degré de hiérarchie désiré.
L'intérêt de cette méthode est de créer une partition hiérarchique dans le réseau, permettant un meilleur contrôle des sous-ensembles de capteurs.
Par ailleurs, les clusters situés tout en bas dans la hiérarchie constituée seront de petite taille.
Les communications intra-clusters seront donc peu consommatrices en énergie.

Pour pouvoir distinguer plus facilement le niveau de hiérarchie auquel nous nous plaçons, nous désignerons par la suite sous le terme \textit{$k$-cluster} ($0 \leq k \leq$~nombre de capteurs) un sous-ensemble obtenu après $k$ applications de l'algorithme de \idx{clusterisation}.
En suivant cette convention, l'unique $0$-cluster est alors le réseau tout entier.
Lorsque nous parlons simplement de \textit{clusters}, il faudra comprendre \textit{$1$-clusters}; autrement dit, des clusters issus d'une partition simple, sans degré supplémentaire de hiérarchie.

De même, on désignera par \textit{$k$-\ch} (ou bien par \textit{$k$-CH}) les \chs de chacun des $k$-clusters du réseau.
Le rôle de $0$-cluster pourra alors être attribué à la \sdb.
Chaque \textit{$k$-CH} reçoit des données (provenant soit de nœuds normaux si $k$ est le dernier degré de la hiérarchie constituée, soit de \textit{$k+1$-CH}), les agrège et les transmet au \textit{$k-1$-CH} auquel il est rattaché.

        \subsubsection{Exemple: fonctionnement de l'algorithme \leach}%
        \label{st:subsubsec:leach}
L'un des algorithmes de \idx{clusterisation} les plus simples et les plus couramment employés dans les \rcsfs est l'algorithme \leach (\textit{Low Energy Adaptive Clustering Hierarchy with deterministic \ch selection}).
Il s'agit d'un algorithme dynamique (il effectue de nouvelles clusterisations\index{clusterisation} du réseau régulièrement dans le temps) qui, par la formation de clusters, met en place une solution de routage des paquets dans le réseau.

Voici le fonctionnement détaillé de cet algorithme.
Soit $P$ le pourcentage moyen de clusters que nous désirons obtenir dans le réseau à un instant quelconque $t$.
\leach est découpé (dans la durée) en cycles, chacun constitué de $\frac{1}{P}$~rondes.
Chaque ronde $r$  est organisée de la façon suivante:
\begin{enumerate}
    \item Chaque nœud du réseau à partitionner calcule une valeur de seuil $S(i)$:
        \[
            S(i) = \left\{
            \begin{array}{cl}
                \displaystyle \frac{P}{1-P\cdot\left(r\mbox{ mod }\frac{1}{P}\right)} & \mbox{si }i\mbox{ n'a pas encore été \CH}\\
                                                                                    0 & \mbox{si }i\mbox{ a déjà été \CH}
            \end{array}
            \right.
        \]
        Chaque nœud choisit un nombre pseudo-aléatoire $0 \le x_{i}\le 1$.
        Si $x_{i} \le S(i)$, alors $i$ s'auto-désigne comme \CH pour la ronde en cours.
        Il est à noter que le calcul de $S(i)$ est réalisé de telle façon que chaque nœud devienne \ch une fois et une fois seulement au cours de chaque cycle de $\frac{1}{P}$~rondes: le taux de probabilité d'auto-désignation $S(i)$ est égal à $1$ lorsque la fin du cycle est atteinte (autrement dit, lorsque $r = \frac{1}{P}-1$).
    \item Les \chs auto-désignés informent leurs nœuds voisins de leur changement de statut à l'aide de messages en \textit{broadcast}.
        Tous ces messages sont envoyés en utilisant la même puissance de transmission (valeur fixe et prédéterminée lors de l'implémentation).
        Pour limiter les collisions, il est fait usage de la méthode \textit{Carrier Sense Multiple Access} (\csma) au niveau de la couche MAC.
    \item Les autres nœuds, qui ne se sont pas désignés en tant que \chs pour la ronde en cours, choisissent de se joindre au cluster du \CH dont ils perçoivent le signal avec l'intensité la plus élevée, \cad le \CH le plus proche en termes d'émissions électromagnétiques.
        Chaque nœud prévient le \ch qu'il décide de rejoindre en lui envoyant un message.
        La méthode \csma est là encore appliquée.
    \item Au vu des réponses reçues, chaque \ch calcule un «~ordre de transmission~» pour les nœuds qui l'ont rejoint.
        Il annonce alors à chacun de ces nœuds l'instant auquel le nœud doit lui transmettre ses données.
        Dans chaque cluster, les nœuds s'adresseront donc à leur \ch à tour de rôle, selon l'ordre déterminé par le \CH, ce qui revient à utiliser la méthode appelée \textit{Time Division Multiple Access} (\tdma).
    \item La phase de collecte des données peut débuter.
        Les \chs restent en écoute et reçoivent les données des autres capteurs de leur cluster.
        Les capteurs «~normaux~» effectuent leur mission (en général, ils réalisent des mesures sur leur environnement), et envoient leurs résultats au \ch lorsque c'est à leur tour de le faire.
        Lorsque ce n'est pas à leur tour de communiquer, ces nœuds mettent leur équipement radio en veille afin d'économiser leur énergie.
        Les collisions entre les transmissions des nœuds de différents clusters sont évitées grâce à la méthode appelée \textit{Code Division Multiple Access} (\cdma).
    \item Au fur et à mesure qu'ils reçoivent les données, les \chs agrègent\idx{agrégation}, et éventuellement compressent\idx{compression} ces dernières.
        Ils les envoient ensuite à la \sdb, soit au cours d'une unique transmission directe, soit en faisant relayer les paquets par d'autres \chs.
    \item Les étapes~5 et~6 sont répétées jusqu'à la fin de la ronde.
\end{enumerate}

Plusieurs remarques sont à énoncer.
Tout d'abord: pour un cluster donné, il est alors possible de réitérer l'application de l'algorithme \leach, afin de créer une nouvelle partition au sein même d'un cluster.
Et ainsi de suite par récursivité, jusqu'à obtenir le degré de hiérarchie\index{clusterisation!clusterisation hiérarchique} désiré dans le réseau.
Nous appellerons $k$-\leach cet algorithme appliqué de façon à créer $k$ degrés hiérarchiques.

Seconde remarque: il est possible d'étendre \leach pour prendre en compte l'énergie restante dont dispose chaque nœud lors de l'élection des \CH.
Cette énergie restante intervient alors en temps que paramètre supplémentaire lors du calcul de la valeur de seuil $S(i)$~\cite{HHT02}.

Troisième point: l'un des aspects importants de \leach est que lors de la première étape, chaque nœud choisi d'être, ou non, un \ch pour la ronde en cours.
Ce choix est basé uniquement sur la valeur de seuil calculée, et sur le nombre pseudo-aléatoire généré; à aucun moment un nœud ne fait intervenir dans sa décision le comportement de ses voisins.
En conséquence, le pourcentage $P$ de \chs désirés dans le réseau n'est qu'une valeur moyenne sur l'ensemble des rondes de chaque cycle.
Par ailleurs, la répartition géographique (au regard de la puissance de transmission nécessaire) idéale des \chs n'est en rien assuré.
Au contraire, il est même probable d'obtenir, pour certaines rondes, une concentration importante de \chs dans une zone restreinte du réseau, tandis que d'autres régions seront mal couvertes.
Il n'y a pas grand-chose à faire dans ce cas, sinon espérer que la prochaine ronde sera plus favorable.
Si toutefois un nœud ne parvient à capter les messages d'aucun \ch, il se déclare généralement lui-même \CH.


\bigskip
But the main purpose of clustering a sensor network usually resides in scaling possibilities, improved nodes management and energy savings brought by partitioning.
Several clustering algorithms have been proposed~\cite{AY07}.

One of the easiest clustering algorithm to implement, and probably one of the most used is the \leach algorithm~\cite{HHT02}.
\leach makes each node draw a pseudo-random number and match it with a threshold which was computed from the number of desired \chs in the network and from the last iteration when the sensor was selected as a \CH.
There is a number of proposals derived from \leach, to improve either its efficiency~\cite{RR13,CJ14} or its security~\cite{OFVWBDL07}.
Other example clustering algorithms include HEED~\cite{YF04} or FFUCA~\cite{FMMMI12}.

VSR\cite{TV08}

        \subsection{Sécurité, \idx{sureté} et \resilience}



Beside being energy-efficient, it is important for an algorithm to \emph{just work}, and thus for researchers to provide guaranties of its functioning.
Formal method may help in this, and one of the most interesting techniques is model-checking.
It is a formal method based technique for verifying finite-state-concurrent systems, and can automatically extract performance or safety properties from a model and to ensure they are asserted at all time in the network.
Additionally, were a system not to work properly, model-checking tools provide a trace to help finding the source of the error.
Contrary to testing or simulation, results obtained \via model-checking do not vary between distinct running instances; more important, formal specification enables one to verify the system against every single execution trace, where testing would only raise some encountered errors (maybe not all existing errors).
Model-checking is used in a wide area of applications, from the validation of network protocols to the verification of safety properties in regard with the non-collision between platoon vehicles\cite{E-ZCGGK12}, for example.

One of the two aforementioned papers already makes use of formal methods, including model-checking, to evaluate its proposal\cite{BMM13}.
A first attempt is described in the study to model it with CTMC (Continuous Time Markov Chains), but limitations due to the period over which the detection is performed led to put away Markovian processes.
Instead the nodes and the monitoring agents are modeled with eGSPN (extended Generalized Stochastic Petri Networks), a class of Petri networks including times transitions and suitable for representing stochastic processes.
From those eGSPNs we could extract a number of performance and dependability properties formally expressed in terms of the Hybrid Automata Stochastic Logic (HASL\cite{BDDHP11hasl}) and relying on Linear Hybrid Automata (LHA).
These properties were eventually asserted with the COSMOS statistical model-checker\cite{BDDHP11cosmos}.

Other works include model-checking of WSN-addressed systems, though we found few of them concerning protection against \DoS attacks.
In~\cite{TCCDC09} for example, three security protocols are analyzed through model-checking, nominally TinySec, allowing authentication and encryption, and LEAP and TinyPK, both used for key management. 
The authors used the AVISTA model-checker, designed for verifying security protocols.
In our study, we prefer to work with the more general UPPAAL model-checking tool.


%La sureté et la résilience des réseaux ne sont pas des problématiques de sécurité (car aucune attaque volontaire ne rentre en compte), mais il s'agit de problématiques assez proches de la disponibilité des réseaux.

        \subsubsection{Sécurité}
En raison de leurs faibles capacités, conjuguées aux domaines critiques dans lesquels ils interviennent parfois, les capteurs peuvent présenter des cibles de choix pour un attaquant.
Les algorithmes et mécanismes classiques utilisés en \idx{cryptographie} afin d'assurer la confidentialité ou l'authentification des données sont souvent très exigeants en ressources (en termes de calculs notamment, et donc de consommation énergétique).
Il a fallu adapter ces mécanismes aux capteurs.

D'autres attaques peuvent être menées, non plus pour intercepter des données, mais dans le but de perturber le bon fonctionnement du réseau.
Ce sont les attaques dites de \textit{\dds}.
Un attaquant, par le biais d'un nœud compromis par exemple, peut ainsi chercher à détourner des flux de données au sein du réseau, à empêcher des paquets de parvenir à destination (en les supprimant), à maximiser le débit du nœud compromis au détriment de celui des autres nœuds, à saturer le canal de transmission pour empêcher les nœuds légitimes de l'utiliser, ou encore à pousser les autres capteurs à l'épuisement de leurs réserves en énergie, \etc.
Les problématiques de sécurité dans les \rcs sont développées plus en détail dans le \chapref{ea}.

\todo{Corriger ici}
Notre but est ici de proposer, modéliser et tester une solution permettant de détecter, puis de réagir à une attaque de ce type, tout en assurant une consommation minimale en ressources pour les capteurs du réseau.

        \subsection{Déploiement autonome, \idx{mobilité}}
    scalabilité

    MANET, VANET
    \cite{DYK12}
\nomenclature{MANET}{\textit{Mobile Ad hoc Networks}}
\nomenclature{VANET}{\textit{Vehicular Ad hoc Networks}}
